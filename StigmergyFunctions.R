#' Stigmergy functions
#' May 6, 2019
#' Lauren White



#############################################################################################
#############################################################################################

#' Function that returns vector locations of a matrix from x,y positions
#' @param row - y value
#' @param col - x value
#' @param nrows - dimension of a square matrix

Cmatrix<-function (row, col, nrows) #y,x
{
  vector_loc <- row + (col - 1) * nrows
  return(vector_loc)
}

#############################################################################################
#############################################################################################
#' Function that returns matrix locations from vector positions
#' @param vector_loc - vector locations
#' @param nrows - dimension of a square matrix

Rmatrix<-function (vector_loc, nrows) 
{
  col <- floor(vector_loc/nrows) + 1
  row <- vector_loc - (col - 1) * nrows + 1
  return(list(col = col, row = row))
}



#############################################################################################
#############################################################################################


#' Function to randomly generate individuals across a landscape, and randomly assign 'nI' number of infected
#' individuals at t=0
#' @param n.initial- the number of desired individuals to start with
#' @param dim- the length (1D) of the landscape
#' @param nI- the number of infected individuals to start with at t=0
#' @author Lauren White
make.inds <- function(n.initial,dim, nI){
  id<-1:n.initial
  xloc<-round(runif(n.initial, min=1, max=dim))
  yloc<-round(runif(n.initial, min=1, max=dim))
  vec<-Cmatrix(yloc,xloc,dim)
  I<-sample(1:n.initial, nI)
  status<-rep("S", times=n.initial)
  status[I]<-"I"
  inds <- data.frame(id = id, xloc=xloc, yloc=yloc, vec=vec, status=status, stringsAsFactors=FALSE) 
  inds
}
#inds<-make.inds(5, 5, 1)

#############################################################################################
#############################################################################################


#' Function to create a landscape of n x n dimensions for N animals, to keep track of scent mark
#' locations
#' @param lsize -dimensions of landscapes
#' @param N - number of animals on the landscape
#' @param inds - dataframe object generated by `make.inds` function
#' @param dur_scent - duration of scent mark time steps

createland<- function(lsize, N, inds, dur_scent)
{
  landscape<- array(0, dim= c(lsize, lsize, N)) #y, x, one layer for each individual
  for(i in 1:nrow(inds))
  {
    landscape[inds$yloc[i], inds$xloc[i], i]<- dur_scent #row, column, layer
    print(i)
  }
  return(landscape)
}

#test<-createland(lsize=5, N=5, inds=inds, dur_scent=10)


#############################################################################################
#############################################################################################


#' Calculate coordinates of neighboring cells
#' Given a neighborhood size and starting coordinates, calculate the coordinates of all cells in the neighborhoods around each starting location.
#' @param loc matrix. Two columns representing matrix coordinates of current locations.
#' @param mapdim vector. The number of rows and columns in the map of interest.
#' @param rowcol.delta matrix. The relative coordinates of the neighborhood of interest (identical for all locations).
#' @param n.offset integer. Used to define the neighborhood if needed (i.e., the number of cells on any side of the starting cell to include in the neighborhood)
#' @param torus logical. If TRUE will wrap the map matrix into a torus to remove edge effects.
#' @param na.val numeric. Value to assign locations that fall off of map (if torus == FALSE).
#' @param ... Other parameters to pass through.
#' @author James Forester
#' @modified May 12, 2017 by Lauren White; switched order of row/columns in Cmatrix conversion
#' @export
#' get.neighbors(loc=loc,mapdim=mapdim,rowcol.delta=rowcol.delta,torus=TRUE, na.val=0)

get.neighbors <- function(loc, mapdim, rowcol.delta=NULL, n.offset, torus=TRUE, na.val=NA, ...){
  
  if(is.null(rowcol.delta)){
    rowcol.delta<- expand.grid(-n.offset:n.offset,-n.offset:n.offset)
  }
  
  neighborhood<-nrow(rowcol.delta) #e.g. an offset of 1, yields 9 neighbors
  outmat<-matrix(NA,nrow(loc),neighborhood) #rows= number of inds./col.= size of neighborhood
  
  for(i in 1:neighborhood){
    newloc=cbind(loc[,1]+rowcol.delta[i,1], loc[,2]+rowcol.delta[i,2])
    
    if(torus){
      ##Wrap map to torus
      newloc[newloc[,1]<=0,1]=mapdim[1]+newloc[newloc[,1]<=0,1]
      newloc[newloc[,2]<=0,2]=mapdim[2]+newloc[newloc[,2]<=0,2]
      newloc[newloc[,1]>mapdim[1],1] = newloc[newloc[,1]>mapdim[1],1]-mapdim[1]
      newloc[newloc[,2]>mapdim[2],2] = newloc[newloc[,2]>mapdim[2],2]-mapdim[2]
    }else{
      newloc[newloc[,1]<=0,1]=na.val
      newloc[newloc[,2]<=0,2]=na.val
      newloc[newloc[,1]>mapdim[1],1] = na.val
      newloc[newloc[,2]>mapdim[2],2] = na.val
    }
    
    outmat[,i]=Cmatrix(newloc[,2],newloc[,1],nrows=mapdim[1]) #row, col, nrows
  }
  
  return(outmat)
}

#############################################################################################
#############################################################################################


sampfun<-function(x){
  ## A convenience function to use with apply when sampling values from rows within a matrix.
  sample(x, size=1) 
}
#############################################################################################
#############################################################################################


calc.dens<-function(hab1, newloc.vec, n.initial, inds){
  consdens<-hab1*0
  idens<-hab1*0
  for(i in 1:length(newloc.vec)) {
    consdens[newloc.vec[i]]=consdens[newloc.vec[i]]+1
    if(inds$status[i]=="I"){
      idens[newloc.vec[i]]=idens[newloc.vec[i]]+1
    }
  }
  dens<-consdens/max(consdens) #normalize to 1 by dividiing conspecific density by maximum number of individuals found in a single cell in the landscape
  Num<-list(consdens,idens,dens) #returns (as list): number of conspecifcs per cell, number of infected conspecifcs per cell, and normalized density
  return(Num)
}

#############################################################################################
#############################################################################################
