#' Stigmergy functions
#' May 6, 2019
#' Lauren White



#############################################################################################
#############################################################################################

#' Function that returns vector locations of a matrix from x,y positions
#' @param row - y value
#' @param col - x value
#' @param nrows - dimension of a square matrix

Cmatrix<-function (row, col, nrows) #y,x
{
  vector_loc <- row + (col - 1) * nrows
  return(vector_loc)
}

#############################################################################################
#############################################################################################
#' Function that returns matrix locations from vector positions
#' @param vector_loc - vector locations
#' @param nrows - dimension of a square matrix

Rmatrix<-function (vector_loc, nrows) 
{
  col <- floor(vector_loc/nrows) + 1
  row <- vector_loc - (col - 1) * nrows + 1
  return(list(col = col, row = row))
}



#############################################################################################
#############################################################################################


#' Function to randomly generate individuals across a landscape, and randomly assign 'nI' number of infected
#' individuals at t=0
#' @param n.initial- the number of desired individuals to start with
#' @param dim- the length (1D) of the landscape
#' @param nI- the number of infected individuals to start with at t=0
#' @author Lauren White
make.inds <- function(n.initial,dim, nI){
  id<-1:n.initial
  xloc<-round(runif(n.initial, min=1, max=dim))
  yloc<-round(runif(n.initial, min=1, max=dim))
  vec<-Cmatrix(yloc,xloc,dim)
  I<-sample(1:n.initial, nI)
  status<-rep("S", times=n.initial)
  status[I]<-"I"
  inds <- data.frame(id = id, xloc=xloc, yloc=yloc, vec=vec, status=status, stringsAsFactors=FALSE)
  inds$dir<-rep(5, times=n.initial) #set previous movement direction column, starting value of 5 = same cell 
  inds$scent_exp<- rep(0, times = n.initial)
  inds
}
#inds<-make.inds(5, 5, 1)

#############################################################################################
#############################################################################################


#' Function to create a landscape of n x n dimensions for N animals, to keep track of scent mark
#' locations
#' @param lsize -dimensions of landscapes
#' @param inds - dataframe object generated by `make.inds` function
#' @param dur_scent - duration of scent mark time steps
#' @param infected - boolean, if TRUE create infection landscape

createland<- function(lsize, inds, dur_scent, infected)
{
  landscape<- array(0, dim= c(lsize, lsize, nrow(inds))) #y, x, one layer for each individual
  if(infected==FALSE){
  for(i in 1:nrow(inds))
  {
    landscape[inds$yloc[i], inds$xloc[i], i]<- dur_scent #row, column, layer
  }
  }
  if(infected==TRUE){
    infID<-which(inds$status=="I")
    for(i in 1:length(infID))
    {
      landscape[inds$yloc[i], inds$xloc[i], infID[i]]<- dur_scent #row, column, layer
    }
  }
  return(landscape)
}

#test<-createland(lsize=5, N=5, inds=inds, dur_scent=10)


#############################################################################################
#############################################################################################


#' Calculate coordinates of neighboring cells
#' Given a neighborhood size and starting coordinates, calculate the coordinates of all cells in the neighborhoods around each starting location.
#' @param loc matrix. Two columns representing matrix coordinates of current locations.
#' @param mapdim vector. The number of rows and columns in the map of interest.
#' @param rowcol.delta matrix. The relative coordinates of the neighborhood of interest (identical for all locations).
#' @param n.offset integer. Used to define the neighborhood if needed (i.e., the number of cells on any side of the starting cell to include in the neighborhood)
#' @param torus logical. If TRUE will wrap the map matrix into a torus to remove edge effects.
#' @param na.val numeric. Value to assign locations that fall off of map (if torus == FALSE).
#' @param ... Other parameters to pass through.
#' @author James Forester
#' @modified May 12, 2017 by Lauren White; switched order of row/columns in Cmatrix conversion
#' @export
#' get.neighbors(loc=loc,mapdim=mapdim,rowcol.delta=rowcol.delta,torus=TRUE, na.val=0)

get.neighbors <- function(loc, mapdim, rowcol.delta=NULL, n.offset, torus=TRUE, na.val=NA, ...){
  
  if(is.null(rowcol.delta)){
    rowcol.delta<- expand.grid(-n.offset:n.offset,-n.offset:n.offset)
  }
  
  neighborhood<-nrow(rowcol.delta) #e.g. an offset of 1, yields 9 neighbors
  outmat<-matrix(NA,nrow(loc),neighborhood) #rows= number of inds./col.= size of neighborhood
  
  for(i in 1:neighborhood){
    newloc=cbind(loc[,1]+rowcol.delta[i,1], loc[,2]+rowcol.delta[i,2])
    
    if(torus){
      ##Wrap map to torus
      newloc[newloc[,1]<=0,1]=mapdim[1]+newloc[newloc[,1]<=0,1]
      newloc[newloc[,2]<=0,2]=mapdim[2]+newloc[newloc[,2]<=0,2]
      newloc[newloc[,1]>mapdim[1],1] = newloc[newloc[,1]>mapdim[1],1]-mapdim[1]
      newloc[newloc[,2]>mapdim[2],2] = newloc[newloc[,2]>mapdim[2],2]-mapdim[2]
    }else{
      newloc[newloc[,1]<=0,1]=na.val
      newloc[newloc[,2]<=0,2]=na.val
      newloc[newloc[,1]>mapdim[1],1] = na.val
      newloc[newloc[,2]>mapdim[2],2] = na.val
    }
    
    outmat[,i]=Cmatrix(newloc[,2],newloc[,1],nrows=mapdim[1]) #row, col, nrows
  }
  
  return(outmat)
}

#############################################################################################
#############################################################################################


sampfun<-function(x){
  ## A convenience function to use with apply when sampling values from rows within a matrix.
  sample(x, size=1)
  # index_val<-x[choose]
  # return(c(choose, index_val))
}

index_val<-function(x, samp){
  
}
#############################################################################################
#############################################################################################
#' A sampling function that returns the new sampled location and the direction of travel [1,9]
#' @param possible_loc - possible movement values generated from get.neighbors function
#' @param inds - dataframe of individual traits
samp_direction<-function(x){
  sample(x, size=1, prob=prob_mat)
}

#############################################################################################
#############################################################################################
#' @param possible_loc - possible movement values generated from get.neighbors function
#' @param inds - dataframe of individual traits
new.cell<-function(possible_loc, inds, lsize){
  inds$vec<-apply(possible_loc, 1, sampfun)
  for(i in 1:nrow(inds)){
    inds$dir[i]<-which(possible_loc[i,] %in% inds$vec[i])
  }
  #dir_index<-apply(possible_loc, 1, function (x) {which(x %in% newloc.vec)})
  #update positions
  newloc<-as.data.frame(Rmatrix(inds$vec-1,lsize))
  ##Update location lists
  inds$xloc<-newloc[,1] #col
  inds$yloc<-newloc[,2] #row
  return(inds)
}

#############################################################################################
#############################################################################################
#' @param possible_loc - possible movement values generated from get.neighbors function
#' @param inds - dataframe of individual traits
new.cell.directed<-function(possible_loc, inds, prob_mat, lsize){
  for(j in 1:nrow(inds)){
    if(sum(inds$scent_exp>0)){
      prob_scent<-inds$scent_exp[j]/sum(inds$scent_exp) #normalize?
      prob_scent<-min(1, prob_scent) #threshold? 
      dir<- ifelse(rbinom(1,1, prob_scent)==1, inds$dir[j], 5) #if the coin flip =1, use previous direction; otherwise, set all directions to equal likelihood
    # dir<-ifelse(inds$scent_exp[j]>0, inds$dir[j], 5) #if exposed to scent on previous step, use previous direction; otherwise, set all directions to equal likelihood
    }
    if(sum(inds$scent_exp==0)){
      dir<-5
    }
      inds$vec[j]<-sample(possible_loc[j,], 1, prob=prob_mat[dir,])

  }
  for(i in 1:nrow(inds)){
    inds$dir[i]<-which(possible_loc[i,] %in% inds$vec[i])
  }
  #dir_index<-apply(possible_loc, 1, function (x) {which(x %in% newloc.vec)})
  #update positions
  newloc<-as.data.frame(Rmatrix(inds$vec-1,lsize))
  ##Update location lists
  inds$xloc<-newloc[,1] #col
  inds$yloc<-newloc[,2] #row
  return(inds)
}

#############################################################################################
#############################################################################################

#'Function that returns as a list: the total number of conspecifics per cell, number of infected conspecifics per cell, and normalized density
#' @author Lauren White
#' @param lsize - landscape layer size (one dimension)
#' @param inds - dataframe of current individual locations & traits including inds$vec
#' @return Num - (as list): number of conspecifcs per cell [[1]], number of infected conspecifcs per cell [[2]], and normalized density [[3]]
calc.dens<-function(lsize, inds){
  loc.vec<-inds$vec
  ncon<- nS<- nI<- matrix(0, nrow= lsize, ncol=lsize) 
  for(i in 1:length(loc.vec)) {
    ncon[loc.vec[i]]=ncon[loc.vec[i]]+1
    if(inds$status[i]=="S"){
      nS[loc.vec[i]]=nS[loc.vec[i]]+1
    }
    if(inds$status[i]=="I"){
      nI[loc.vec[i]]=nI[loc.vec[i]]+1
    }
  }
  dens<-ncon/max(ncon) #normalize to 1 by dividiing conspecific density by maximum number of individuals found in a single cell in the landscape
  Num<-list(ncon,nS,nI,dens) #returns (as list): number of conspecifcs per cell, number of infected conspecifcs per cell, and normalized density
  return(Num)
}

#############################################################################################
#############################################################################################


#' Function that determines whether not a transmission event occurs
#' First checks to see if there are any individuals + infected infividuals present in the same cell
#' Then calculates final transmission probability based on # of infected individuals present
#' @param inds- dataframe with individual traits, including infection status
#' @param nS- matrix of susceptible conspecifics by cell location
#' @param nI- matrix of infected conspecifics by cell location
#' @param transProb- per interaction transmission probability
#' @param lxy- convenience data frame for vector to xy notation

#' @author Lauren White
#' @date May 6, 2019
#' 
infect_direct<-function(inds, nS, nI, transProb, lxy){
  i_cells<-which(nS>0 & nI>0) #Which cells have at least one infected, and at least one other susceptible individual present
  for (i in 1:length(i_cells)){
    loc<-lxy[i_cells[i],]
    s_inds<-which(inds$xloc==loc$lx & inds$yloc==loc$ly & inds$status=="S")
    i_count<-length(which(inds$xloc==loc$lx & inds$yloc==loc$ly & inds$status=="I"))
    finalProb <- 1 - (1 - transProb)^i_count
    transmit <- rbinom(length(s_inds), 1, finalProb)
    new_i<-s_inds[which(transmit == 1)]
    inds$status[new_i]<-"I"
  } 
  return(inds)
}


#############################################################################################
#############################################################################################

#' Function that determines whether not a transmission event occurs from environmental/indirect transmission
#' First checks to see if there are any individuals + infected infividuals present in the same cell
#' Then calculates final transmission probability based on # of infected individuals present
#' @param inds- dataframe with individual traits, including infection status
#' @param nS- matrix of susceptible conspecifics by cell location
#' @param nI- matrix of infected conspecifics by cell location
#' @param transProb- per interaction transmission probability
#' @param lxy- convenience data frame for vector to xy notation

#' @author Lauren White
#' @date May 7, 2019
#' 
infect_indirect<-function(inds, nS, nI, transProb, lxy, inf_landscape){
  i_cells<-which(nS>0 & inf_landscape>0) #which cells have susceptible individuals and environmental pathogen load?
  if(length(i_cells>0)){
  for (i in 1:length(i_cells)){
    loc<-lxy[i_cells[i],]
    s_inds<-which(inds$xloc==loc$lx & inds$yloc==loc$ly & inds$status=="S")
    i_load<-inf_landscape[[i_cells[i]]]
    finalProb <- min(1, i_load) #if calculated load exceeds 1, floor/limit to one (for example, if multiple animals have visited same cell at same time step)
    transmit <- rbinom(length(s_inds), 1, finalProb)
    new_i<-s_inds[which(transmit == 1)]
    inds$status[new_i]<-"I"
    }
  }
  return(inds)
}


#############################################################################################
#############################################################################################

#' Function that allows infected individuals to recover at rate 'gamma'
#' @param inds: the dataframe describing the current status and location of individuals in the simulation
#' @param gamma: the recovery rate
#' @author Lauren White
recover.inds<-function(inds, gamma){
  infected<-which(inds$status=="I" ) #which individuals are currently infected?
  if(length(infected>0)){
    rec.prob<-runif(length(infected), min=0, max=1)
    for (i in 1:length(infected)){
      if(rec.prob[i]<= gamma){
        inds$status[infected[i]]<-"R"
      }
    }
  }
  return(inds)
}

#############################################################################################
#############################################################################################

#'Convenience function to calculate xy coordinates that correspond to numeric length of matrix
#'assigns numbers vertically per default settings in R
#'column-x 
#'row-y
#'@param dim: dimension (1D) of landscape
longxy<-function(dim){
  ly <- rep(1:dim, dim)
  lx <- rep(1:dim, each=dim)
  lxy <- data.frame(lx,ly)
  lxy
}

#############################################################################################
#############################################################################################

#Create probability matrix
create.prob<-function(){
  prob_mat<-matrix(0, nrow=9, ncol=9) #9 directions (col) and 9 neighboring cells (row)
  prob_mat[1, c(6,8,9)]<-1/3 #direction 1, upper left
  prob_mat[2, c(7,8,9)]<-1/3# 2 = upper
  prob_mat[3, c(4,7,8)]<-1/3# 3 = upper right 
  prob_mat[4, c(3,6,9)]<-1/3# 4 = left
  prob_mat[5,]<- 1/9# 5 = same--> all
  prob_mat[6, c(1,4,7)]<-1/3 # 6 = right 
  prob_mat[7, c(2,3,6)]<-1/3# 7 = lower left 
  prob_mat[8, c(1,2,3)]<-1/3# 8 = lower
  prob_mat[9, c(1,2,4)]<-1/3# 9 = 9 lower right 
  return(prob_mat)
}

#############################################################################################
#############################################################################################