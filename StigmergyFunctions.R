#' Stigmergy functions
#' May 6, 2019
#' Lauren White



#############################################################################################
#############################################################################################

#' Function that returns vector locations of a matrix from x,y positions
#' @param row - y value
#' @param col - x value
#' @param nrows - dimension of a square matrix

Cmatrix<-function (row, col, nrows) #y,x
{
  vector_loc <- row + (col - 1) * nrows
  return(vector_loc)
}

#############################################################################################
#############################################################################################
#' Function that returns matrix locations from vector positions
#' @param vector_loc - vector locations
#' @param nrows - dimension of a square matrix

Rmatrix<-function (vector_loc, nrows) 
{
  col <- floor(vector_loc/nrows) + 1
  row <- vector_loc - (col - 1) * nrows + 1
  return(list(col = col, row = row))
}



#############################################################################################
#############################################################################################


#' Function to randomly generate individuals across a landscape, and randomly assign 'nI' number of infected
#' individuals at t=0
#' @param n.initial- the number of desired individuals to start with
#' @param dim- the length (1D) of the landscape
#' @param nI- the number of infected individuals to start with at t=0
#' @author Lauren White
make.inds <- function(n.initial,dim, nI){
  id<-1:n.initial
  xloc<-round(runif(n.initial, min=1, max=dim))
  yloc<-round(runif(n.initial, min=1, max=dim))
  vec<-Cmatrix(yloc,xloc,dim)
  I<-sample(1:n.initial, nI)
  status<-rep("S", times=n.initial)
  status[I]<-"I"
  inds <- data.frame(id = id, xloc=xloc, yloc=yloc, vec=vec, status=status, stringsAsFactors=FALSE) 
  inds
}
#inds<-make.inds(5, 5, 1)

#############################################################################################
#############################################################################################


#' Function to create a landscape of n x n dimensions for N animals, to keep track of scent mark
#' locations
#' @param lsize -dimensions of landscapes
#' @param N - number of animals on the landscape
#' @param inds - dataframe object generated by `make.inds` function
#' @param dur_scent - duration of scent mark time steps
#' @param infected - boolean, if TRUE create infection landscape

createland<- function(lsize, N, inds, dur_scent, infected)
{
  landscape<- array(0, dim= c(lsize, lsize, N)) #y, x, one layer for each individual
  if(infected==FALSE){
  for(i in 1:nrow(inds))
  {
    landscape[inds$yloc[i], inds$xloc[i], i]<- dur_scent #row, column, layer
    print(i)
  }
  }
  if(infected==TRUE){
    infID<-which(inds$status=="I")
    for(i in 1:length(infID))
    {
      landscape[inds$yloc[i], inds$xloc[i], infID[i]]<- dur_scent #row, column, layer
      print(i)
    }
  }
  return(landscape)
}

#test<-createland(lsize=5, N=5, inds=inds, dur_scent=10)


#############################################################################################
#############################################################################################


#' Calculate coordinates of neighboring cells
#' Given a neighborhood size and starting coordinates, calculate the coordinates of all cells in the neighborhoods around each starting location.
#' @param loc matrix. Two columns representing matrix coordinates of current locations.
#' @param mapdim vector. The number of rows and columns in the map of interest.
#' @param rowcol.delta matrix. The relative coordinates of the neighborhood of interest (identical for all locations).
#' @param n.offset integer. Used to define the neighborhood if needed (i.e., the number of cells on any side of the starting cell to include in the neighborhood)
#' @param torus logical. If TRUE will wrap the map matrix into a torus to remove edge effects.
#' @param na.val numeric. Value to assign locations that fall off of map (if torus == FALSE).
#' @param ... Other parameters to pass through.
#' @author James Forester
#' @modified May 12, 2017 by Lauren White; switched order of row/columns in Cmatrix conversion
#' @export
#' get.neighbors(loc=loc,mapdim=mapdim,rowcol.delta=rowcol.delta,torus=TRUE, na.val=0)

get.neighbors <- function(loc, mapdim, rowcol.delta=NULL, n.offset, torus=TRUE, na.val=NA, ...){
  
  if(is.null(rowcol.delta)){
    rowcol.delta<- expand.grid(-n.offset:n.offset,-n.offset:n.offset)
  }
  
  neighborhood<-nrow(rowcol.delta) #e.g. an offset of 1, yields 9 neighbors
  outmat<-matrix(NA,nrow(loc),neighborhood) #rows= number of inds./col.= size of neighborhood
  
  for(i in 1:neighborhood){
    newloc=cbind(loc[,1]+rowcol.delta[i,1], loc[,2]+rowcol.delta[i,2])
    
    if(torus){
      ##Wrap map to torus
      newloc[newloc[,1]<=0,1]=mapdim[1]+newloc[newloc[,1]<=0,1]
      newloc[newloc[,2]<=0,2]=mapdim[2]+newloc[newloc[,2]<=0,2]
      newloc[newloc[,1]>mapdim[1],1] = newloc[newloc[,1]>mapdim[1],1]-mapdim[1]
      newloc[newloc[,2]>mapdim[2],2] = newloc[newloc[,2]>mapdim[2],2]-mapdim[2]
    }else{
      newloc[newloc[,1]<=0,1]=na.val
      newloc[newloc[,2]<=0,2]=na.val
      newloc[newloc[,1]>mapdim[1],1] = na.val
      newloc[newloc[,2]>mapdim[2],2] = na.val
    }
    
    outmat[,i]=Cmatrix(newloc[,2],newloc[,1],nrows=mapdim[1]) #row, col, nrows
  }
  
  return(outmat)
}

#############################################################################################
#############################################################################################


sampfun<-function(x){
  ## A convenience function to use with apply when sampling values from rows within a matrix.
  sample(x, size=1) 
}
#############################################################################################
#############################################################################################

#'Function that returns as a list: the total number of conspecifics per cell, number of infected conspecifics per cell, and normalized density
#' @author Lauren White
#' @param lsize - landscape layer size (one dimension)
#' @param newloc.vec - locations in vector notation
#' @param n.initial - number of initial conspecifics on landscapes
#' @param inds - dataframe of current individual locations & traits
calc.dens<-function(lsize, newloc.vec, n.initial, inds){
  ncon<- nS<- nI<- matrix(0, nrow= lsize, ncol=lsize) 
  for(i in 1:length(newloc.vec)) {
    ncon[newloc.vec[i]]=ncon[newloc.vec[i]]+1
    if(inds$status[i]=="S"){
      nS[newloc.vec[i]]=nS[newloc.vec[i]]+1
    }
    if(inds$status[i]=="I"){
      nI[newloc.vec[i]]=nI[newloc.vec[i]]+1
    }
  }
  dens<-ncon/max(ncon) #normalize to 1 by dividiing conspecific density by maximum number of individuals found in a single cell in the landscape
  Num<-list(ncon,nS,nI,dens) #returns (as list): number of conspecifcs per cell, number of infected conspecifcs per cell, and normalized density
  return(Num)
}

#############################################################################################
#############################################################################################


#    inds<-infection3(inds, consdens=as.numeric(Num[[1]]), idens=as.numeric(Num[[2]]), transProb=inf_prob, hab1=hab1)
#' Function that determines whether not a transmission event occurs
#' First checks to see if there are any individuals + infected infividuals present in the same cell
#' Then calculates final transmission probability based on # of infected individuals present
#' @param inds- dataframe with individual traits, including infection status
#' @param consdens- number of conspecifics by cell
#' @param idens- number of infected conspecifics by cell
#' @param transProb- per interaction transmissioin probability
#' @param lxy- convenience data frame for vector to xy notation

#' @author Lauren White
#' @date May 25, 2017
#' 
infection3<-function(inds, nS, nI, transProb, lxy){
  i_cells<-which(nS>0 & nI>0) #Which cells have at least one infected, and at least one other susceptible individual present
  for (i in 1:length(i_cells)){
    loc<-lxy[i_cells[i],]
    s_inds<-which(inds$xloc==loc$lx & inds$yloc==loc$ly & inds$status=="S")
    i_count<-length(which(inds$xloc==loc$lx & inds$yloc==loc$ly & inds$status=="I"))
    finalProb <- 1 - (1 - transProb)^i_count
    transmit <- rbinom(length(s_inds), 1, finalProb)
    new_i<-s_inds[which(transmit == 1)]
    inds$status[new_i]<-"I"
  } 
  return(inds)
}


#############################################################################################
#############################################################################################

#'Convenience function to calculate xy coordinates that correspond to numeric length of matrix
#'assigns numbers vertically per default settings in R
#'column-x 
#'row-y
#'@param dim: dimension (1D) of landscape
longxy<-function(dim){
  ly <- rep(1:dim, dim)
  lx <- rep(1:dim, each=dim)
  lxy <- data.frame(lx,ly)
  lxy
}

#############################################################################################
#############################################################################################